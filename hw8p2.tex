\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{algorithm}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage[noend]{algorithmic}
\usepackage{enumerate}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{stackrel}

% Helpful Shortcuts
\newcommand{\bc}[1]{{\quad \text{(#1)}}} 	% Justification in math env
\newcommand{\st}{{\text{ such that }}} 							   % Math env
\newcommand{\abs}[1]{{ |#1 |}} 							% Absolute value / Cardinality
\newcommand{\bld}[2]{\noindent\textbf{#1:}\hspace{0.1in}#2$  $\bigskip} % Headings
\newcommand{\notimplies}{%
	\mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}
\newcommand{\linesep}{\noindent\bigskip\rule{17cm}{0.1mm}\bigskip} % Horizontal Line

% These define new environments / formats for lemmas, definitions, running time, etc.
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem*{claim}{Claim}
\newtheorem{observation}{Observation}
\newtheorem{conjecture}[lemma]{Conjecture}
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem*{rt}{Running Time}

% These define nice ways to format P and OPT (use \P or \opt)
\def\P{\ensuremath{$ \mathcal{P} $}}
\def\opt{\ensuremath{\textsc{opt}}}
\renewcommand{\labelenumi}{\bf \alph{enumi}.}

\renewcommand\maketitle{
	\begin{center}
		\begin{tabular*}{6.44in}{l @{\extracolsep{\fill}}c r}
			\bfseries  &  & \bfseries CSCI 383 Spring 2019 \\
			\bfseries&  & \bfseries  Homework \#? Solutions  \\
			\bfseries   &   &  \bfseries Kai Ting Keshia Yap\\ 
		\end{tabular*}
\end{center} }

\begin{document}
	\maketitle
	
	\noindent Honor Code: I affirm that I adhered to the Honor Code in this assignment. Keshia Yap
	\subsection*{Part 2: Rooting for You}
	Suppose $ L\subseteq \Sigma^* $ is a language. Define $ Root(L) = \{x\in\Sigma^*\mid xx\in L\}. $ Prove that if $ L $ is recursive, then Root(L) is recursive. 
	
	\linesep
	\begin{proof}
		Given that $ L $ is recursive, there is a total turing machine $ M=(Q,\Sigma,  \Gamma, \vdash, \textvisiblespace,\delta, s, t, r) $ such that $ L(M) =L(L)$, i.e. the language of $ M $ is exactly that of $ L $. Let $ M'=(Q',\Sigma,  \Gamma', \vdash, \textvisiblespace,\delta', s_0, t, r) $ be a turing machine that basically duplicates $ x $ on the tape, and then runs the transitions in $ \delta $ (to check if $ xx $ is in $ L$). That is, 
		\begin{itemize}
			\item $ Q'=Q\sqcup\{s_0,s_1\}\sqcup \{q_c\mid c\in\Sigma\} $ 
			\item $ \Gamma' = \Gamma\sqcup \{\hat{c}\mid c\in\Sigma \} $
			\item $\delta'$ contains all transitions in $ \delta $, as well as transitions that duplicate $ x $ on the tape
		\end{itemize}
	
%	\begin{algorithm}
	\begin{algorithmic}
		\WHILE{in state $ s_0 $}
		\WHILE{in state $ s_0 $}
		\STATE sweep right  (the transition $ ((s_0, \hat{c}),(s_0,\hat{c}, R)) $)
		\IF{we read an unmarked character $ c $}
		\STATE replace the character with $ \hat{c} $ 
		\STATE transition to state $ q_c $ (the transition $ ((s_0, c),(q_c,\hat{c}, R)) $)\\
		\ENDIF
		\ENDWHILE		
		\WHILE{in state $ q_c $}
			\STATE sweep right  (the transition $ ((q_c, c),(q_c,\c, R)),  ((q_c, \hat{c}),(q_c,\hat{c}, R)) $)
		\IF{we read $ \textvisiblespace $}
		\STATE replace it with $ \hat{c} $  and transition to $ s_1 $ (the transition $ ((q_c, \textvisiblespace),(s_1,\hat{c}, L)) $)
		\ENDIF
		\ENDWHILE
		\WHILE{in state $ s_1 $}
		\STATE sweep left (the transition $ ((s_1, c),(s_1,\c, L)),  ((s_1, \hat{c}),(s_1,\hat{c}, L)) $)
		\IF{we read some unmarked character $ c$}
		\STATE transition to state $ s_0 $ (the transition $ ((s_1, c),(s_0,c, L)) $)
		\ENDIF
		\IF{we read $ \vdash$}
		\STATE transition to state $ s $ (the transition $ ((s_1, \vdash),(s_1,\vdash, R)) $)
		\ENDIF
		\ENDWHILE
		\ENDWHILE
		\STATE Now perform transitions on the tape as if in machine $ M $\\
		\IF{it is accepted}
		\RETURN accept $ x $
		\ENDIF
		\IF{it is rejected, then reject $ x $}
		\RETURN reject $ x $
		\ENDIF
	\end{algorithmic}
%	\end{algorithm}

%		\begin{algorithm}
%			While in state $ s_0 $\\
%			- sweep right until we read an unmarked character $ c $\\
%			- - replace the character with $ \hat{c} $ and transition to state $ q_c $ (the transition $ ((s_0, c),(q_c,\hat{c}, R)) $)\\
%			- sweep right till we read the first $ \textvisiblespace $, and replace it with $ \hat{c} $  (the transition $ ((q_c, \textvisiblespace),(s_1,\hat{c}, L)) $)\\
%			- sweep left until we read an unmarked character (loop $ ((s_1, \hat{c}),(s_1,\hat{c}, L))) $\\
%			- - if we read an unmarked character, transition to $ s_0 $ (loop $((s_1, c),(s_0,c, L)) $)\\
%			- sweep left until we read $ \vdash $ \\
%			(loop the transitions $ ((s_0, c),(s_0,c, L)), ((s_0, \hat{c}),(s_0,\hat{c}, L)), ((s_1, c),(s_1,c, L)), ((s_1, \hat{c}),(s_1,\hat{c}, L)) $)\\
%			- upon reading the $ \vdash $ symbol, move right one step $ (((s_0,\vdash), (s_0, \vdash, R)), ((s_1,\vdash), (s_1, \vdash, R))) $\\ \\
%			
%			If in state $ s_1 $
%			- sweep right and remove all markings from characters (loop $ ((s_1,\hat{c}),(s_1,c, R)) $)\\
%			- upon reading $ \textvisiblespace $, transition to state $ s $ (use $ ((s_1,\textvisiblespace),(s,\textvisiblespace, L)) $)\\
%			- sweep left to $ \vdash $ (loop $ ((s,c),(s,c, L)) $)\\\\
%			
%			Now perform transitions on the tape as if in machine $ M $\\
%			- if it transitions to state $ t $ at some point, then accept $ x $\\
%			- else it will transition to state $ r $ at some point, where we will reject $ x $.
%		\end{algorithm}
	
	It is clear to see that $ L(M')=Root(L) $. Namely, if $ x\in L(M')\iff  xx\in L \iff x\in Root(L) $. Since $ M' $ is total, $ Root(L) $ is recursive.
	\end{proof}
\end{document}