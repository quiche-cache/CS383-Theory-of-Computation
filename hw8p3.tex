\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{enumerate}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{stackrel}

% Helpful Shortcuts
\newcommand{\bc}[1]{{\quad \text{(#1)}}} 	% Justification in math env
\newcommand{\st}{{\text{ such that }}} 							   % Math env
\newcommand{\abs}[1]{{ |#1 |}} 							% Absolute value / Cardinality
\newcommand{\bld}[2]{\noindent\textbf{#1:}\hspace{0.1in}#2$  $\bigskip} % Headings
\newcommand{\notimplies}{%
	\mathrel{{\ooalign{\hidewidth$\not\phantom{=}$\hidewidth\cr$\implies$}}}}
\newcommand{\linesep}{\noindent\bigskip\rule{17cm}{0.1mm}\bigskip} % Horizontal Line

% These define new environments / formats for lemmas, definitions, running time, etc.
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem*{claim}{Claim}
\newtheorem{observation}{Observation}
\newtheorem{conjecture}[lemma]{Conjecture}
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem*{rt}{Running Time}

% These define nice ways to format P and OPT (use \P or \opt)
\def\P{\ensuremath{$ \mathcal{P} $}}
\def\opt{\ensuremath{\textsc{opt}}}
\renewcommand{\labelenumi}{\bf \alph{enumi}.}

\renewcommand\maketitle{
	\begin{center}
		\begin{tabular*}{6.44in}{l @{\extracolsep{\fill}}c r}
			\bfseries  &  & \bfseries CSCI 383 Spring 2019 \\
			\bfseries&  & \bfseries  Homework \#8 Solutions  \\
			\bfseries   &   &  \bfseries Kai Ting Keshia Yap\\ 
		\end{tabular*}
\end{center} }

\begin{document}
	\maketitle
	
	\noindent Honor Code: I affirm that I adhered to the Honor Code in this assignment. Keshia Yap\\
	
	
	\subsection*{Part 3: I’m running out of closure property jokes.}
	Suppose $ A $ and $ B $ are recursive languages. Prove the following facts:
	\begin{enumerate}[1.]
	\item $ A \cup B $ is recursive.
	\item $ A \cap B $ is recursive.
	\item $ AB $ is recursive.
	\item $ A^* $
	\end{enumerate}
	is recursive.
	
%For each part, you should describe your construction at a very high level. You may write pseudocode like you would in, say, CSCI 280, without describing how the Turing machine manages basic computational tasks such as checking that strings are equal and managing storage on the tape. In other words, your description should look a lot like rough description of a program that has black box access to total Turing machines for A and B. As an example, it would be okay to say something like “Test if $ x $ is of even length, and divide it into two even halves, $ y $ and $ z $. Run $ M $ on $ zy $.”
	\linesep
	
	\noindent Since $ A $ and $ B $ are recursive languages, there exists two total Turing machines $ M_A $ and $ M_B $ where $ L(M_A)=A $ and $ L(M_B)=B $. Recall that Turing machines with multiple tapes has equivalent computational power to Turing machines with single tapes, so it suffices to build total Turing machines with an arbitrary number of tapes that accept precisely each of the languages above
	
	\begin{enumerate}[1.]
		\item \begin{proof}
			Let $ M_1 $ be a Turing machine with two tapes, where the first tape obeys the $ \delta $ transitions and contains the states of $ M_A $ while the second tape obeys the $ \delta $ transitions and contains the states of $ M_B$. Copy the input onto both tapes and run the machines. Accept if either one of the tapes enters their respective accept states, and reject if both tapes enter their respective reject states. Since 
			\[x\in L(M_2)\iff  x\in L(M_A)\lor x\in L(M_B) 
			\iff x\in A \lor  x\in B
			\iff x\in A \cap B, \] we conclude that $ L(M_1)=A\cup B $.
		\end{proof}

		\item 
			Let $ M_2 $ be a Turing machine with similar set-up to $ M_1 $. Copy the input onto both tapes and run the machines. Accept if both of the the tapes enter their respective accept states, and reject otherwise. Since 
			\[x\in L(M_2)\iff  x\in L(M_A)\land x\in L(M_B) 
			\iff x\in A\land x\in B
			\iff x\in A \cap B,\] we conclude that $ L(M_2)=A\cap B $.
	\item 
			Let $ M_3 $ be a Turing machine with similar set-up to $ M_1 $. Given an input $ x $, find all possible partitions $ x=yz $ where $ y,z\in \Sigma^* $ and for each partition, run $ y $ on the first tape and then $ z $ on the second tape. If both tapes enter their respective accept states for some partition $ x=yz $, accept $ x $. Otherwise, reject $ x $. \\
			
	\begin{claim}
		$ L(M_3)=AB $
	\end{claim}
	\begin{proof}
			\begin{align*}
				x\in L(M_3)&\iff \exists y,z\in\Sigma^*\st x=yz, y\in L(M_A), z\in L(M_B) \\
				&\iff y\in A, z\in B\\
				&\iff x=yz\in AB
			\end{align*}
		\end{proof}
	\item \begin{proof}
			Let $ M_4 $ be a Turing machine with some input $ x $. First, $ M_4 $ finds all partitions of $ x=y_1y_2...y_k $ where $ y_i\in\Sigma^* $ for all $ i\in\{1,2,...,k\} $. For every partition, run every $ y_i $ on a separate tape to check if $ y_i\in L(M_A) $. If the tape enters the reject state for any $ y_i $, try a new partition that has not been run previously. If there exists some partition $  x=y_1y_2...y_k $ such that $ y_i\in L(M_A) $ for all $ i\in\{1,2,...,k\} $, accept $ x $. Otherwise, reject $ x $.
		\end{proof}
	
	\begin{claim}
		$ L(M_4)=A^* $
	\end{claim}
	\begin{proof}
		\begin{align*}
		x\in L(M_4)&\iff \exists y_1,y_2,\dots, y_k\in\Sigma^*\st x=y_1y_2\dots y_k, \text{ and }y_i\in L(M_A)\forall i\in\{1,2,\dots,k\}\\
		&\iff \exists y_1,y_2,\dots, y_k\in\Sigma^*\st x=y_1y_2\dots y_k, \text{ and }y_i\in A\forall i\in\{1,2,\dots,k\}\\
		&\iff x\in A^*
		\end{align*}
	\end{proof}
	\end{enumerate}
\end{document}